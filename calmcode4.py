# -*- coding: utf-8 -*-
"""CalmCode4

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I4atVujP5Ivlv45Lozf1NpgUwe3Y-uen

# Manjinder Sandhu
https://github.com/ManjinderUNCC/dsba6188--calm-code-4

# annoy
"""

!pip install annoy

import numpy as np
import matplotlib.pylab as plt
from annoy import AnnoyIndex

columns = 2

vecs = np.concatenate([
    np.random.normal(-1, 1, (5000, columns)),
    np.random.normal(0, 0.5, (5000, columns)),
])

plt.scatter(vecs[:, 0], vecs[:, 1], s=1);

annoy = AnnoyIndex(columns, 'euclidean')
for i in range(vecs.shape[0]):
    annoy.add_item(i, vecs[i, :])
annoy.build(n_trees=1)

plt.figure(figsize=(5, 5))
plt.scatter(vecs[:, 0], vecs[:, 1], s=1);

indices = annoy.get_nns_by_vector(np.array([-0., -0.]), 20)

subset = vecs[indices, :]
plt.scatter(subset[:, 0], subset[:, 1], s=1);

plt.figure(figsize=(5, 5))
plt.scatter(vecs[:, 0], vecs[:, 1], s=1);

indices = annoy.get_nns_by_vector(np.array([-0., -0.]), 2000)

subset = vecs[indices, :]
plt.scatter(subset[:, 0], subset[:, 1], s=1);

plt.figure(figsize=(5, 5))
plt.scatter(vecs[:, 0], vecs[:, 1], s=1);

indices = annoy.get_nns_by_vector(np.array([-1., -1.]), 2000)

subset = vecs[indices, :]
plt.scatter(subset[:, 0], subset[:, 1], s=1);

annoy = AnnoyIndex(columns, 'euclidean')
for i in range(vecs.shape[0]):
    annoy.add_item(i, vecs[i, :])
annoy.build(n_trees=10)

plt.figure(figsize=(5, 5))
plt.scatter(vecs[:, 0], vecs[:, 1], s=1);

indices = annoy.get_nns_by_vector(np.array([-1., -1.]), 2000)

subset = vecs[indices, :]
plt.scatter(subset[:, 0], subset[:, 1], s=1);

from sklearn.neighbors import NearestNeighbors
query = np.array([-2., -2.])
q = np.array([query])
n = 10

nn = NearestNeighbors(n_neighbors=n, algorithm='ball_tree').fit(vecs)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# distances, indices = nn.kneighbors(q)

nn = NearestNeighbors(n_neighbors=n, algorithm='kd_tree').fit(vecs)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# distances, indices = nn.kneighbors(q)

nn = NearestNeighbors(n_neighbors=n, algorithm='brute').fit(vecs)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# distances, indices = nn.kneighbors(q)

annoy = AnnoyIndex(columns, 'euclidean')
for i in range(vecs.shape[0]):
    annoy.add_item(i, vecs[i, :])
annoy.build(n_trees=10)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# annoy.get_nns_by_vector(query, n)

annoy = AnnoyIndex(columns, 'euclidean')
for i in range(vecs.shape[0]):
    annoy.add_item(i, vecs[i, :])
annoy.build(n_trees=1)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# annoy.get_nns_by_vector(query, n)

columns = 2
vecs = np.concatenate([
    np.random.normal(-1, 1, (5000, columns)),
    np.random.normal(0, 0.5, (5000, columns)),
])

metric = 'euclidean'

annoy = AnnoyIndex(columns, metric)
for i in range(vecs.shape[0]):
    annoy.add_item(i, vecs[i, :])
annoy.build(n_trees=1)

annoy.save('test.ann')
annoy_from_disk = AnnoyIndex(columns, metric)
annoy_from_disk.load('test.ann')

"""# Lambda"""

def double(x):
    return x * 2

double(3)

triple = lambda x: x * 3

triple(3)

def double(x):
    return x * 2

number = 1
for func in [double, double, double]:
    number = func(number)
    print(number)

def add_one(x):
    return x + 1

number = 1
for func in [add_one, double, add_one]:
    number = func(number)
    print(number)

number = 1
for func in [lambda x: x + 1, lambda x: x * 2, lambda x: x + 2]:
    number = func(number)
    print(number)

number = 1
for func in [lambda x: x - 1, lambda x: x * 2, lambda x: x + 2]:
    number = func(number)
    print(number)

from functools import reduce

numbers = [1, 2, 3, 4, 5]

reduce(lambda x, y: x + y, numbers)

reduce(lambda x, y: x * y, numbers)

import numpy as np
import pandas as pd

df = pd.DataFrame(np.random.normal(0, 1, (10, 2)))
df.columns = ['column_a', 'column_b']
df

df.loc[lambda d: d['column_b'] > 0]